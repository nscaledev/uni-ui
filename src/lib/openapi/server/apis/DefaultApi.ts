/* tslint:disable */
/* eslint-disable */
/**
 * Kubernetes Service API
 * The Kubernetes Service API provides services that allows provisioning and life cycle management of Kubernetes clusters. The API is logically composed of authentication services, platform provider specific calls to get a set of resource types that can be then used by abstract Kubernetes Service resources to create and manage Kubernetes clusters. Requests must specify the HTML content type header.
 *
 * The version of the OpenAPI document: 0.2.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as runtime from '../runtime';
import type {
  Applications,
  ClusterManagerSpec,
  ClusterManagers,
  Flavors,
  Images,
  KubernetesClusterSpec,
  KubernetesClusters,
  Oauth2Error,
  Regions,
} from '../models/index';
import {
    ApplicationsFromJSON,
    ApplicationsToJSON,
    ClusterManagerSpecFromJSON,
    ClusterManagerSpecToJSON,
    ClusterManagersFromJSON,
    ClusterManagersToJSON,
    FlavorsFromJSON,
    FlavorsToJSON,
    ImagesFromJSON,
    ImagesToJSON,
    KubernetesClusterSpecFromJSON,
    KubernetesClusterSpecToJSON,
    KubernetesClustersFromJSON,
    KubernetesClustersToJSON,
    Oauth2ErrorFromJSON,
    Oauth2ErrorToJSON,
    RegionsFromJSON,
    RegionsToJSON,
} from '../models/index';

export interface ApiV1OrganizationsOrganizationNameClustermanagersGetRequest {
    organizationName: string;
}

export interface ApiV1OrganizationsOrganizationNameClustersGetRequest {
    organizationName: string;
}

export interface ApiV1OrganizationsOrganizationNameProjectsProjectNameClustermanagersClusterManagerNameDeleteRequest {
    organizationName: string;
    projectName: string;
    clusterManagerName: string;
}

export interface ApiV1OrganizationsOrganizationNameProjectsProjectNameClustermanagersClusterManagerNamePutRequest {
    organizationName: string;
    projectName: string;
    clusterManagerName: string;
    clusterManagerSpec: ClusterManagerSpec;
}

export interface ApiV1OrganizationsOrganizationNameProjectsProjectNameClustermanagersPostRequest {
    organizationName: string;
    projectName: string;
    clusterManagerSpec: ClusterManagerSpec;
}

export interface ApiV1OrganizationsOrganizationNameProjectsProjectNameClustersClusterNameDeleteRequest {
    organizationName: string;
    projectName: string;
    clusterName: string;
}

export interface ApiV1OrganizationsOrganizationNameProjectsProjectNameClustersClusterNameKubeconfigGetRequest {
    organizationName: string;
    projectName: string;
    clusterName: string;
}

export interface ApiV1OrganizationsOrganizationNameProjectsProjectNameClustersClusterNamePutRequest {
    organizationName: string;
    projectName: string;
    clusterName: string;
    kubernetesClusterSpec: KubernetesClusterSpec;
}

export interface ApiV1OrganizationsOrganizationNameProjectsProjectNameClustersPostRequest {
    organizationName: string;
    projectName: string;
    kubernetesClusterSpec: KubernetesClusterSpec;
}

export interface ApiV1RegionsRegionNameFlavorsGetRequest {
    regionName: string;
}

export interface ApiV1RegionsRegionNameImagesGetRequest {
    regionName: string;
}

/**
 * 
 */
export class DefaultApi extends runtime.BaseAPI {

    /**
     * Lists applications available to be installed on clusters.
     */
    async apiV1ApplicationsGetRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Applications>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("oauth2Authentication", []);
        }

        const response = await this.request({
            path: `/api/v1/applications`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ApplicationsFromJSON(jsonValue));
    }

    /**
     * Lists applications available to be installed on clusters.
     */
    async apiV1ApplicationsGet(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Applications> {
        const response = await this.apiV1ApplicationsGetRaw(initOverrides);
        return await response.value();
    }

    /**
     * Lists cluster managers within the organization.
     */
    async apiV1OrganizationsOrganizationNameClustermanagersGetRaw(requestParameters: ApiV1OrganizationsOrganizationNameClustermanagersGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ClusterManagers>> {
        if (requestParameters.organizationName === null || requestParameters.organizationName === undefined) {
            throw new runtime.RequiredError('organizationName','Required parameter requestParameters.organizationName was null or undefined when calling apiV1OrganizationsOrganizationNameClustermanagersGet.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("oauth2Authentication", []);
        }

        const response = await this.request({
            path: `/api/v1/organizations/{organizationName}/clustermanagers`.replace(`{${"organizationName"}}`, encodeURIComponent(String(requestParameters.organizationName))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ClusterManagersFromJSON(jsonValue));
    }

    /**
     * Lists cluster managers within the organization.
     */
    async apiV1OrganizationsOrganizationNameClustermanagersGet(requestParameters: ApiV1OrganizationsOrganizationNameClustermanagersGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ClusterManagers> {
        const response = await this.apiV1OrganizationsOrganizationNameClustermanagersGetRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * List all clusters within the organization.
     */
    async apiV1OrganizationsOrganizationNameClustersGetRaw(requestParameters: ApiV1OrganizationsOrganizationNameClustersGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<KubernetesClusters>> {
        if (requestParameters.organizationName === null || requestParameters.organizationName === undefined) {
            throw new runtime.RequiredError('organizationName','Required parameter requestParameters.organizationName was null or undefined when calling apiV1OrganizationsOrganizationNameClustersGet.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("oauth2Authentication", []);
        }

        const response = await this.request({
            path: `/api/v1/organizations/{organizationName}/clusters`.replace(`{${"organizationName"}}`, encodeURIComponent(String(requestParameters.organizationName))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => KubernetesClustersFromJSON(jsonValue));
    }

    /**
     * List all clusters within the organization.
     */
    async apiV1OrganizationsOrganizationNameClustersGet(requestParameters: ApiV1OrganizationsOrganizationNameClustersGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<KubernetesClusters> {
        const response = await this.apiV1OrganizationsOrganizationNameClustersGetRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Deletes a cluster manager from within the scoped project. This is a cascading operation and will delete all contained clusters.
     */
    async apiV1OrganizationsOrganizationNameProjectsProjectNameClustermanagersClusterManagerNameDeleteRaw(requestParameters: ApiV1OrganizationsOrganizationNameProjectsProjectNameClustermanagersClusterManagerNameDeleteRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.organizationName === null || requestParameters.organizationName === undefined) {
            throw new runtime.RequiredError('organizationName','Required parameter requestParameters.organizationName was null or undefined when calling apiV1OrganizationsOrganizationNameProjectsProjectNameClustermanagersClusterManagerNameDelete.');
        }

        if (requestParameters.projectName === null || requestParameters.projectName === undefined) {
            throw new runtime.RequiredError('projectName','Required parameter requestParameters.projectName was null or undefined when calling apiV1OrganizationsOrganizationNameProjectsProjectNameClustermanagersClusterManagerNameDelete.');
        }

        if (requestParameters.clusterManagerName === null || requestParameters.clusterManagerName === undefined) {
            throw new runtime.RequiredError('clusterManagerName','Required parameter requestParameters.clusterManagerName was null or undefined when calling apiV1OrganizationsOrganizationNameProjectsProjectNameClustermanagersClusterManagerNameDelete.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("oauth2Authentication", []);
        }

        const response = await this.request({
            path: `/api/v1/organizations/{organizationName}/projects/{projectName}/clustermanagers/{clusterManagerName}`.replace(`{${"organizationName"}}`, encodeURIComponent(String(requestParameters.organizationName))).replace(`{${"projectName"}}`, encodeURIComponent(String(requestParameters.projectName))).replace(`{${"clusterManagerName"}}`, encodeURIComponent(String(requestParameters.clusterManagerName))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Deletes a cluster manager from within the scoped project. This is a cascading operation and will delete all contained clusters.
     */
    async apiV1OrganizationsOrganizationNameProjectsProjectNameClustermanagersClusterManagerNameDelete(requestParameters: ApiV1OrganizationsOrganizationNameProjectsProjectNameClustermanagersClusterManagerNameDeleteRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.apiV1OrganizationsOrganizationNameProjectsProjectNameClustermanagersClusterManagerNameDeleteRaw(requestParameters, initOverrides);
    }

    /**
     * Updates a cluster manager within the scoped project.
     */
    async apiV1OrganizationsOrganizationNameProjectsProjectNameClustermanagersClusterManagerNamePutRaw(requestParameters: ApiV1OrganizationsOrganizationNameProjectsProjectNameClustermanagersClusterManagerNamePutRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.organizationName === null || requestParameters.organizationName === undefined) {
            throw new runtime.RequiredError('organizationName','Required parameter requestParameters.organizationName was null or undefined when calling apiV1OrganizationsOrganizationNameProjectsProjectNameClustermanagersClusterManagerNamePut.');
        }

        if (requestParameters.projectName === null || requestParameters.projectName === undefined) {
            throw new runtime.RequiredError('projectName','Required parameter requestParameters.projectName was null or undefined when calling apiV1OrganizationsOrganizationNameProjectsProjectNameClustermanagersClusterManagerNamePut.');
        }

        if (requestParameters.clusterManagerName === null || requestParameters.clusterManagerName === undefined) {
            throw new runtime.RequiredError('clusterManagerName','Required parameter requestParameters.clusterManagerName was null or undefined when calling apiV1OrganizationsOrganizationNameProjectsProjectNameClustermanagersClusterManagerNamePut.');
        }

        if (requestParameters.clusterManagerSpec === null || requestParameters.clusterManagerSpec === undefined) {
            throw new runtime.RequiredError('clusterManagerSpec','Required parameter requestParameters.clusterManagerSpec was null or undefined when calling apiV1OrganizationsOrganizationNameProjectsProjectNameClustermanagersClusterManagerNamePut.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("oauth2Authentication", []);
        }

        const response = await this.request({
            path: `/api/v1/organizations/{organizationName}/projects/{projectName}/clustermanagers/{clusterManagerName}`.replace(`{${"organizationName"}}`, encodeURIComponent(String(requestParameters.organizationName))).replace(`{${"projectName"}}`, encodeURIComponent(String(requestParameters.projectName))).replace(`{${"clusterManagerName"}}`, encodeURIComponent(String(requestParameters.clusterManagerName))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: ClusterManagerSpecToJSON(requestParameters.clusterManagerSpec),
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Updates a cluster manager within the scoped project.
     */
    async apiV1OrganizationsOrganizationNameProjectsProjectNameClustermanagersClusterManagerNamePut(requestParameters: ApiV1OrganizationsOrganizationNameProjectsProjectNameClustermanagersClusterManagerNamePutRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.apiV1OrganizationsOrganizationNameProjectsProjectNameClustermanagersClusterManagerNamePutRaw(requestParameters, initOverrides);
    }

    /**
     * Creates a new cluster manager within the project.
     */
    async apiV1OrganizationsOrganizationNameProjectsProjectNameClustermanagersPostRaw(requestParameters: ApiV1OrganizationsOrganizationNameProjectsProjectNameClustermanagersPostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.organizationName === null || requestParameters.organizationName === undefined) {
            throw new runtime.RequiredError('organizationName','Required parameter requestParameters.organizationName was null or undefined when calling apiV1OrganizationsOrganizationNameProjectsProjectNameClustermanagersPost.');
        }

        if (requestParameters.projectName === null || requestParameters.projectName === undefined) {
            throw new runtime.RequiredError('projectName','Required parameter requestParameters.projectName was null or undefined when calling apiV1OrganizationsOrganizationNameProjectsProjectNameClustermanagersPost.');
        }

        if (requestParameters.clusterManagerSpec === null || requestParameters.clusterManagerSpec === undefined) {
            throw new runtime.RequiredError('clusterManagerSpec','Required parameter requestParameters.clusterManagerSpec was null or undefined when calling apiV1OrganizationsOrganizationNameProjectsProjectNameClustermanagersPost.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("oauth2Authentication", []);
        }

        const response = await this.request({
            path: `/api/v1/organizations/{organizationName}/projects/{projectName}/clustermanagers`.replace(`{${"organizationName"}}`, encodeURIComponent(String(requestParameters.organizationName))).replace(`{${"projectName"}}`, encodeURIComponent(String(requestParameters.projectName))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: ClusterManagerSpecToJSON(requestParameters.clusterManagerSpec),
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Creates a new cluster manager within the project.
     */
    async apiV1OrganizationsOrganizationNameProjectsProjectNameClustermanagersPost(requestParameters: ApiV1OrganizationsOrganizationNameProjectsProjectNameClustermanagersPostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.apiV1OrganizationsOrganizationNameProjectsProjectNameClustermanagersPostRaw(requestParameters, initOverrides);
    }

    /**
     * Delete a cluster from within a the selected cluster manager.
     */
    async apiV1OrganizationsOrganizationNameProjectsProjectNameClustersClusterNameDeleteRaw(requestParameters: ApiV1OrganizationsOrganizationNameProjectsProjectNameClustersClusterNameDeleteRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.organizationName === null || requestParameters.organizationName === undefined) {
            throw new runtime.RequiredError('organizationName','Required parameter requestParameters.organizationName was null or undefined when calling apiV1OrganizationsOrganizationNameProjectsProjectNameClustersClusterNameDelete.');
        }

        if (requestParameters.projectName === null || requestParameters.projectName === undefined) {
            throw new runtime.RequiredError('projectName','Required parameter requestParameters.projectName was null or undefined when calling apiV1OrganizationsOrganizationNameProjectsProjectNameClustersClusterNameDelete.');
        }

        if (requestParameters.clusterName === null || requestParameters.clusterName === undefined) {
            throw new runtime.RequiredError('clusterName','Required parameter requestParameters.clusterName was null or undefined when calling apiV1OrganizationsOrganizationNameProjectsProjectNameClustersClusterNameDelete.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("oauth2Authentication", []);
        }

        const response = await this.request({
            path: `/api/v1/organizations/{organizationName}/projects/{projectName}/clusters/{clusterName}`.replace(`{${"organizationName"}}`, encodeURIComponent(String(requestParameters.organizationName))).replace(`{${"projectName"}}`, encodeURIComponent(String(requestParameters.projectName))).replace(`{${"clusterName"}}`, encodeURIComponent(String(requestParameters.clusterName))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Delete a cluster from within a the selected cluster manager.
     */
    async apiV1OrganizationsOrganizationNameProjectsProjectNameClustersClusterNameDelete(requestParameters: ApiV1OrganizationsOrganizationNameProjectsProjectNameClustersClusterNameDeleteRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.apiV1OrganizationsOrganizationNameProjectsProjectNameClustersClusterNameDeleteRaw(requestParameters, initOverrides);
    }

    /**
     * Get a cluster\'s Kubernetes configuration.
     */
    async apiV1OrganizationsOrganizationNameProjectsProjectNameClustersClusterNameKubeconfigGetRaw(requestParameters: ApiV1OrganizationsOrganizationNameProjectsProjectNameClustersClusterNameKubeconfigGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.organizationName === null || requestParameters.organizationName === undefined) {
            throw new runtime.RequiredError('organizationName','Required parameter requestParameters.organizationName was null or undefined when calling apiV1OrganizationsOrganizationNameProjectsProjectNameClustersClusterNameKubeconfigGet.');
        }

        if (requestParameters.projectName === null || requestParameters.projectName === undefined) {
            throw new runtime.RequiredError('projectName','Required parameter requestParameters.projectName was null or undefined when calling apiV1OrganizationsOrganizationNameProjectsProjectNameClustersClusterNameKubeconfigGet.');
        }

        if (requestParameters.clusterName === null || requestParameters.clusterName === undefined) {
            throw new runtime.RequiredError('clusterName','Required parameter requestParameters.clusterName was null or undefined when calling apiV1OrganizationsOrganizationNameProjectsProjectNameClustersClusterNameKubeconfigGet.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("oauth2Authentication", []);
        }

        const response = await this.request({
            path: `/api/v1/organizations/{organizationName}/projects/{projectName}/clusters/{clusterName}/kubeconfig`.replace(`{${"organizationName"}}`, encodeURIComponent(String(requestParameters.organizationName))).replace(`{${"projectName"}}`, encodeURIComponent(String(requestParameters.projectName))).replace(`{${"clusterName"}}`, encodeURIComponent(String(requestParameters.clusterName))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Get a cluster\'s Kubernetes configuration.
     */
    async apiV1OrganizationsOrganizationNameProjectsProjectNameClustersClusterNameKubeconfigGet(requestParameters: ApiV1OrganizationsOrganizationNameProjectsProjectNameClustersClusterNameKubeconfigGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.apiV1OrganizationsOrganizationNameProjectsProjectNameClustersClusterNameKubeconfigGetRaw(requestParameters, initOverrides);
    }

    /**
     * Update a cluster within the selected cluster manager.
     */
    async apiV1OrganizationsOrganizationNameProjectsProjectNameClustersClusterNamePutRaw(requestParameters: ApiV1OrganizationsOrganizationNameProjectsProjectNameClustersClusterNamePutRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.organizationName === null || requestParameters.organizationName === undefined) {
            throw new runtime.RequiredError('organizationName','Required parameter requestParameters.organizationName was null or undefined when calling apiV1OrganizationsOrganizationNameProjectsProjectNameClustersClusterNamePut.');
        }

        if (requestParameters.projectName === null || requestParameters.projectName === undefined) {
            throw new runtime.RequiredError('projectName','Required parameter requestParameters.projectName was null or undefined when calling apiV1OrganizationsOrganizationNameProjectsProjectNameClustersClusterNamePut.');
        }

        if (requestParameters.clusterName === null || requestParameters.clusterName === undefined) {
            throw new runtime.RequiredError('clusterName','Required parameter requestParameters.clusterName was null or undefined when calling apiV1OrganizationsOrganizationNameProjectsProjectNameClustersClusterNamePut.');
        }

        if (requestParameters.kubernetesClusterSpec === null || requestParameters.kubernetesClusterSpec === undefined) {
            throw new runtime.RequiredError('kubernetesClusterSpec','Required parameter requestParameters.kubernetesClusterSpec was null or undefined when calling apiV1OrganizationsOrganizationNameProjectsProjectNameClustersClusterNamePut.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("oauth2Authentication", []);
        }

        const response = await this.request({
            path: `/api/v1/organizations/{organizationName}/projects/{projectName}/clusters/{clusterName}`.replace(`{${"organizationName"}}`, encodeURIComponent(String(requestParameters.organizationName))).replace(`{${"projectName"}}`, encodeURIComponent(String(requestParameters.projectName))).replace(`{${"clusterName"}}`, encodeURIComponent(String(requestParameters.clusterName))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: KubernetesClusterSpecToJSON(requestParameters.kubernetesClusterSpec),
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Update a cluster within the selected cluster manager.
     */
    async apiV1OrganizationsOrganizationNameProjectsProjectNameClustersClusterNamePut(requestParameters: ApiV1OrganizationsOrganizationNameProjectsProjectNameClustersClusterNamePutRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.apiV1OrganizationsOrganizationNameProjectsProjectNameClustersClusterNamePutRaw(requestParameters, initOverrides);
    }

    /**
     * Creates a new cluster within the selected cluster manager.
     */
    async apiV1OrganizationsOrganizationNameProjectsProjectNameClustersPostRaw(requestParameters: ApiV1OrganizationsOrganizationNameProjectsProjectNameClustersPostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.organizationName === null || requestParameters.organizationName === undefined) {
            throw new runtime.RequiredError('organizationName','Required parameter requestParameters.organizationName was null or undefined when calling apiV1OrganizationsOrganizationNameProjectsProjectNameClustersPost.');
        }

        if (requestParameters.projectName === null || requestParameters.projectName === undefined) {
            throw new runtime.RequiredError('projectName','Required parameter requestParameters.projectName was null or undefined when calling apiV1OrganizationsOrganizationNameProjectsProjectNameClustersPost.');
        }

        if (requestParameters.kubernetesClusterSpec === null || requestParameters.kubernetesClusterSpec === undefined) {
            throw new runtime.RequiredError('kubernetesClusterSpec','Required parameter requestParameters.kubernetesClusterSpec was null or undefined when calling apiV1OrganizationsOrganizationNameProjectsProjectNameClustersPost.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("oauth2Authentication", []);
        }

        const response = await this.request({
            path: `/api/v1/organizations/{organizationName}/projects/{projectName}/clusters`.replace(`{${"organizationName"}}`, encodeURIComponent(String(requestParameters.organizationName))).replace(`{${"projectName"}}`, encodeURIComponent(String(requestParameters.projectName))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: KubernetesClusterSpecToJSON(requestParameters.kubernetesClusterSpec),
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Creates a new cluster within the selected cluster manager.
     */
    async apiV1OrganizationsOrganizationNameProjectsProjectNameClustersPost(requestParameters: ApiV1OrganizationsOrganizationNameProjectsProjectNameClustersPostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.apiV1OrganizationsOrganizationNameProjectsProjectNameClustersPostRaw(requestParameters, initOverrides);
    }

    /**
     * List all regions.
     */
    async apiV1RegionsGetRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Regions>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("oauth2Authentication", []);
        }

        const response = await this.request({
            path: `/api/v1/regions`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => RegionsFromJSON(jsonValue));
    }

    /**
     * List all regions.
     */
    async apiV1RegionsGet(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Regions> {
        const response = await this.apiV1RegionsGetRaw(initOverrides);
        return await response.value();
    }

    /**
     * Lists all compute flavors that the authenticated user has access to
     */
    async apiV1RegionsRegionNameFlavorsGetRaw(requestParameters: ApiV1RegionsRegionNameFlavorsGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Flavors>> {
        if (requestParameters.regionName === null || requestParameters.regionName === undefined) {
            throw new runtime.RequiredError('regionName','Required parameter requestParameters.regionName was null or undefined when calling apiV1RegionsRegionNameFlavorsGet.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("oauth2Authentication", []);
        }

        const response = await this.request({
            path: `/api/v1/regions/{regionName}/flavors`.replace(`{${"regionName"}}`, encodeURIComponent(String(requestParameters.regionName))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => FlavorsFromJSON(jsonValue));
    }

    /**
     * Lists all compute flavors that the authenticated user has access to
     */
    async apiV1RegionsRegionNameFlavorsGet(requestParameters: ApiV1RegionsRegionNameFlavorsGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Flavors> {
        const response = await this.apiV1RegionsRegionNameFlavorsGetRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Lists all compute images that the authenticated user has access to.
     */
    async apiV1RegionsRegionNameImagesGetRaw(requestParameters: ApiV1RegionsRegionNameImagesGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Images>> {
        if (requestParameters.regionName === null || requestParameters.regionName === undefined) {
            throw new runtime.RequiredError('regionName','Required parameter requestParameters.regionName was null or undefined when calling apiV1RegionsRegionNameImagesGet.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("oauth2Authentication", []);
        }

        const response = await this.request({
            path: `/api/v1/regions/{regionName}/images`.replace(`{${"regionName"}}`, encodeURIComponent(String(requestParameters.regionName))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ImagesFromJSON(jsonValue));
    }

    /**
     * Lists all compute images that the authenticated user has access to.
     */
    async apiV1RegionsRegionNameImagesGet(requestParameters: ApiV1RegionsRegionNameImagesGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Images> {
        const response = await this.apiV1RegionsRegionNameImagesGetRaw(requestParameters, initOverrides);
        return await response.value();
    }

}
