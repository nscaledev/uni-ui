/* tslint:disable */
/* eslint-disable */
/**
 * Kubernetes Service API
 * The Kubernetes Service API provides services that allows provisioning and life cycle management of Kubernetes clusters. The API is logically composed of authentication services, platform provider specific calls to get a set of resource types that can be then used by abstract Kubernetes Service resources to create and manage Kubernetes clusters. Requests must specify the HTML content type header.
 *
 * The version of the OpenAPI document: 0.2.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as runtime from '../runtime';
import type {
  Applications,
  ClusterManagerSpec,
  ClusterManagers,
  Flavors,
  Images,
  KubernetesClusterSpec,
  KubernetesClusters,
  Oauth2Error,
  Regions,
} from '../models/index';
import {
    ApplicationsFromJSON,
    ApplicationsToJSON,
    ClusterManagerSpecFromJSON,
    ClusterManagerSpecToJSON,
    ClusterManagersFromJSON,
    ClusterManagersToJSON,
    FlavorsFromJSON,
    FlavorsToJSON,
    ImagesFromJSON,
    ImagesToJSON,
    KubernetesClusterSpecFromJSON,
    KubernetesClusterSpecToJSON,
    KubernetesClustersFromJSON,
    KubernetesClustersToJSON,
    Oauth2ErrorFromJSON,
    Oauth2ErrorToJSON,
    RegionsFromJSON,
    RegionsToJSON,
} from '../models/index';

export interface ApiV1OrganizationsOrganizationClustermanagersGetRequest {
    organization: string;
}

export interface ApiV1OrganizationsOrganizationClustersGetRequest {
    organization: string;
}

export interface ApiV1OrganizationsOrganizationProjectsProjectClustermanagersClusterManagerDeleteRequest {
    organization: string;
    project: string;
    clusterManager: string;
}

export interface ApiV1OrganizationsOrganizationProjectsProjectClustermanagersClusterManagerPutRequest {
    organization: string;
    project: string;
    clusterManager: string;
    clusterManagerSpec: ClusterManagerSpec;
}

export interface ApiV1OrganizationsOrganizationProjectsProjectClustermanagersPostRequest {
    organization: string;
    project: string;
    clusterManagerSpec: ClusterManagerSpec;
}

export interface ApiV1OrganizationsOrganizationProjectsProjectClustersClusterDeleteRequest {
    organization: string;
    project: string;
    cluster: string;
}

export interface ApiV1OrganizationsOrganizationProjectsProjectClustersClusterKubeconfigGetRequest {
    organization: string;
    project: string;
    cluster: string;
}

export interface ApiV1OrganizationsOrganizationProjectsProjectClustersClusterPutRequest {
    organization: string;
    project: string;
    cluster: string;
    kubernetesClusterSpec: KubernetesClusterSpec;
}

export interface ApiV1OrganizationsOrganizationProjectsProjectClustersPostRequest {
    organization: string;
    project: string;
    kubernetesClusterSpec: KubernetesClusterSpec;
}

export interface ApiV1RegionsRegionNameFlavorsGetRequest {
    regionName: string;
}

export interface ApiV1RegionsRegionNameImagesGetRequest {
    regionName: string;
}

/**
 * 
 */
export class DefaultApi extends runtime.BaseAPI {

    /**
     * Lists applications available to be installed on clusters.
     */
    async apiV1ApplicationsGetRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Applications>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("oauth2Authentication", []);
        }

        const response = await this.request({
            path: `/api/v1/applications`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ApplicationsFromJSON(jsonValue));
    }

    /**
     * Lists applications available to be installed on clusters.
     */
    async apiV1ApplicationsGet(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Applications> {
        const response = await this.apiV1ApplicationsGetRaw(initOverrides);
        return await response.value();
    }

    /**
     * Lists cluster managers within the organization.
     */
    async apiV1OrganizationsOrganizationClustermanagersGetRaw(requestParameters: ApiV1OrganizationsOrganizationClustermanagersGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ClusterManagers>> {
        if (requestParameters.organization === null || requestParameters.organization === undefined) {
            throw new runtime.RequiredError('organization','Required parameter requestParameters.organization was null or undefined when calling apiV1OrganizationsOrganizationClustermanagersGet.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("oauth2Authentication", []);
        }

        const response = await this.request({
            path: `/api/v1/organizations/{organization}/clustermanagers`.replace(`{${"organization"}}`, encodeURIComponent(String(requestParameters.organization))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ClusterManagersFromJSON(jsonValue));
    }

    /**
     * Lists cluster managers within the organization.
     */
    async apiV1OrganizationsOrganizationClustermanagersGet(requestParameters: ApiV1OrganizationsOrganizationClustermanagersGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ClusterManagers> {
        const response = await this.apiV1OrganizationsOrganizationClustermanagersGetRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * List all clusters within the organization.
     */
    async apiV1OrganizationsOrganizationClustersGetRaw(requestParameters: ApiV1OrganizationsOrganizationClustersGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<KubernetesClusters>> {
        if (requestParameters.organization === null || requestParameters.organization === undefined) {
            throw new runtime.RequiredError('organization','Required parameter requestParameters.organization was null or undefined when calling apiV1OrganizationsOrganizationClustersGet.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("oauth2Authentication", []);
        }

        const response = await this.request({
            path: `/api/v1/organizations/{organization}/clusters`.replace(`{${"organization"}}`, encodeURIComponent(String(requestParameters.organization))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => KubernetesClustersFromJSON(jsonValue));
    }

    /**
     * List all clusters within the organization.
     */
    async apiV1OrganizationsOrganizationClustersGet(requestParameters: ApiV1OrganizationsOrganizationClustersGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<KubernetesClusters> {
        const response = await this.apiV1OrganizationsOrganizationClustersGetRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Deletes a cluster manager from within the scoped project. This is a cascading operation and will delete all contained clusters.
     */
    async apiV1OrganizationsOrganizationProjectsProjectClustermanagersClusterManagerDeleteRaw(requestParameters: ApiV1OrganizationsOrganizationProjectsProjectClustermanagersClusterManagerDeleteRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.organization === null || requestParameters.organization === undefined) {
            throw new runtime.RequiredError('organization','Required parameter requestParameters.organization was null or undefined when calling apiV1OrganizationsOrganizationProjectsProjectClustermanagersClusterManagerDelete.');
        }

        if (requestParameters.project === null || requestParameters.project === undefined) {
            throw new runtime.RequiredError('project','Required parameter requestParameters.project was null or undefined when calling apiV1OrganizationsOrganizationProjectsProjectClustermanagersClusterManagerDelete.');
        }

        if (requestParameters.clusterManager === null || requestParameters.clusterManager === undefined) {
            throw new runtime.RequiredError('clusterManager','Required parameter requestParameters.clusterManager was null or undefined when calling apiV1OrganizationsOrganizationProjectsProjectClustermanagersClusterManagerDelete.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("oauth2Authentication", []);
        }

        const response = await this.request({
            path: `/api/v1/organizations/{organization}/projects/{project}/clustermanagers/{clusterManager}`.replace(`{${"organization"}}`, encodeURIComponent(String(requestParameters.organization))).replace(`{${"project"}}`, encodeURIComponent(String(requestParameters.project))).replace(`{${"clusterManager"}}`, encodeURIComponent(String(requestParameters.clusterManager))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Deletes a cluster manager from within the scoped project. This is a cascading operation and will delete all contained clusters.
     */
    async apiV1OrganizationsOrganizationProjectsProjectClustermanagersClusterManagerDelete(requestParameters: ApiV1OrganizationsOrganizationProjectsProjectClustermanagersClusterManagerDeleteRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.apiV1OrganizationsOrganizationProjectsProjectClustermanagersClusterManagerDeleteRaw(requestParameters, initOverrides);
    }

    /**
     * Updates a cluster manager within the scoped project.
     */
    async apiV1OrganizationsOrganizationProjectsProjectClustermanagersClusterManagerPutRaw(requestParameters: ApiV1OrganizationsOrganizationProjectsProjectClustermanagersClusterManagerPutRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.organization === null || requestParameters.organization === undefined) {
            throw new runtime.RequiredError('organization','Required parameter requestParameters.organization was null or undefined when calling apiV1OrganizationsOrganizationProjectsProjectClustermanagersClusterManagerPut.');
        }

        if (requestParameters.project === null || requestParameters.project === undefined) {
            throw new runtime.RequiredError('project','Required parameter requestParameters.project was null or undefined when calling apiV1OrganizationsOrganizationProjectsProjectClustermanagersClusterManagerPut.');
        }

        if (requestParameters.clusterManager === null || requestParameters.clusterManager === undefined) {
            throw new runtime.RequiredError('clusterManager','Required parameter requestParameters.clusterManager was null or undefined when calling apiV1OrganizationsOrganizationProjectsProjectClustermanagersClusterManagerPut.');
        }

        if (requestParameters.clusterManagerSpec === null || requestParameters.clusterManagerSpec === undefined) {
            throw new runtime.RequiredError('clusterManagerSpec','Required parameter requestParameters.clusterManagerSpec was null or undefined when calling apiV1OrganizationsOrganizationProjectsProjectClustermanagersClusterManagerPut.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("oauth2Authentication", []);
        }

        const response = await this.request({
            path: `/api/v1/organizations/{organization}/projects/{project}/clustermanagers/{clusterManager}`.replace(`{${"organization"}}`, encodeURIComponent(String(requestParameters.organization))).replace(`{${"project"}}`, encodeURIComponent(String(requestParameters.project))).replace(`{${"clusterManager"}}`, encodeURIComponent(String(requestParameters.clusterManager))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: ClusterManagerSpecToJSON(requestParameters.clusterManagerSpec),
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Updates a cluster manager within the scoped project.
     */
    async apiV1OrganizationsOrganizationProjectsProjectClustermanagersClusterManagerPut(requestParameters: ApiV1OrganizationsOrganizationProjectsProjectClustermanagersClusterManagerPutRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.apiV1OrganizationsOrganizationProjectsProjectClustermanagersClusterManagerPutRaw(requestParameters, initOverrides);
    }

    /**
     * Creates a new cluster manager within the project.
     */
    async apiV1OrganizationsOrganizationProjectsProjectClustermanagersPostRaw(requestParameters: ApiV1OrganizationsOrganizationProjectsProjectClustermanagersPostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.organization === null || requestParameters.organization === undefined) {
            throw new runtime.RequiredError('organization','Required parameter requestParameters.organization was null or undefined when calling apiV1OrganizationsOrganizationProjectsProjectClustermanagersPost.');
        }

        if (requestParameters.project === null || requestParameters.project === undefined) {
            throw new runtime.RequiredError('project','Required parameter requestParameters.project was null or undefined when calling apiV1OrganizationsOrganizationProjectsProjectClustermanagersPost.');
        }

        if (requestParameters.clusterManagerSpec === null || requestParameters.clusterManagerSpec === undefined) {
            throw new runtime.RequiredError('clusterManagerSpec','Required parameter requestParameters.clusterManagerSpec was null or undefined when calling apiV1OrganizationsOrganizationProjectsProjectClustermanagersPost.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("oauth2Authentication", []);
        }

        const response = await this.request({
            path: `/api/v1/organizations/{organization}/projects/{project}/clustermanagers`.replace(`{${"organization"}}`, encodeURIComponent(String(requestParameters.organization))).replace(`{${"project"}}`, encodeURIComponent(String(requestParameters.project))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: ClusterManagerSpecToJSON(requestParameters.clusterManagerSpec),
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Creates a new cluster manager within the project.
     */
    async apiV1OrganizationsOrganizationProjectsProjectClustermanagersPost(requestParameters: ApiV1OrganizationsOrganizationProjectsProjectClustermanagersPostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.apiV1OrganizationsOrganizationProjectsProjectClustermanagersPostRaw(requestParameters, initOverrides);
    }

    /**
     * Delete a cluster from within a the selected cluster manager.
     */
    async apiV1OrganizationsOrganizationProjectsProjectClustersClusterDeleteRaw(requestParameters: ApiV1OrganizationsOrganizationProjectsProjectClustersClusterDeleteRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.organization === null || requestParameters.organization === undefined) {
            throw new runtime.RequiredError('organization','Required parameter requestParameters.organization was null or undefined when calling apiV1OrganizationsOrganizationProjectsProjectClustersClusterDelete.');
        }

        if (requestParameters.project === null || requestParameters.project === undefined) {
            throw new runtime.RequiredError('project','Required parameter requestParameters.project was null or undefined when calling apiV1OrganizationsOrganizationProjectsProjectClustersClusterDelete.');
        }

        if (requestParameters.cluster === null || requestParameters.cluster === undefined) {
            throw new runtime.RequiredError('cluster','Required parameter requestParameters.cluster was null or undefined when calling apiV1OrganizationsOrganizationProjectsProjectClustersClusterDelete.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("oauth2Authentication", []);
        }

        const response = await this.request({
            path: `/api/v1/organizations/{organization}/projects/{project}/clusters/{cluster}`.replace(`{${"organization"}}`, encodeURIComponent(String(requestParameters.organization))).replace(`{${"project"}}`, encodeURIComponent(String(requestParameters.project))).replace(`{${"cluster"}}`, encodeURIComponent(String(requestParameters.cluster))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Delete a cluster from within a the selected cluster manager.
     */
    async apiV1OrganizationsOrganizationProjectsProjectClustersClusterDelete(requestParameters: ApiV1OrganizationsOrganizationProjectsProjectClustersClusterDeleteRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.apiV1OrganizationsOrganizationProjectsProjectClustersClusterDeleteRaw(requestParameters, initOverrides);
    }

    /**
     * Get a cluster\'s Kubernetes configuration.
     */
    async apiV1OrganizationsOrganizationProjectsProjectClustersClusterKubeconfigGetRaw(requestParameters: ApiV1OrganizationsOrganizationProjectsProjectClustersClusterKubeconfigGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.organization === null || requestParameters.organization === undefined) {
            throw new runtime.RequiredError('organization','Required parameter requestParameters.organization was null or undefined when calling apiV1OrganizationsOrganizationProjectsProjectClustersClusterKubeconfigGet.');
        }

        if (requestParameters.project === null || requestParameters.project === undefined) {
            throw new runtime.RequiredError('project','Required parameter requestParameters.project was null or undefined when calling apiV1OrganizationsOrganizationProjectsProjectClustersClusterKubeconfigGet.');
        }

        if (requestParameters.cluster === null || requestParameters.cluster === undefined) {
            throw new runtime.RequiredError('cluster','Required parameter requestParameters.cluster was null or undefined when calling apiV1OrganizationsOrganizationProjectsProjectClustersClusterKubeconfigGet.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("oauth2Authentication", []);
        }

        const response = await this.request({
            path: `/api/v1/organizations/{organization}/projects/{project}/clusters/{cluster}/kubeconfig`.replace(`{${"organization"}}`, encodeURIComponent(String(requestParameters.organization))).replace(`{${"project"}}`, encodeURIComponent(String(requestParameters.project))).replace(`{${"cluster"}}`, encodeURIComponent(String(requestParameters.cluster))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Get a cluster\'s Kubernetes configuration.
     */
    async apiV1OrganizationsOrganizationProjectsProjectClustersClusterKubeconfigGet(requestParameters: ApiV1OrganizationsOrganizationProjectsProjectClustersClusterKubeconfigGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.apiV1OrganizationsOrganizationProjectsProjectClustersClusterKubeconfigGetRaw(requestParameters, initOverrides);
    }

    /**
     * Update a cluster within the selected cluster manager.
     */
    async apiV1OrganizationsOrganizationProjectsProjectClustersClusterPutRaw(requestParameters: ApiV1OrganizationsOrganizationProjectsProjectClustersClusterPutRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.organization === null || requestParameters.organization === undefined) {
            throw new runtime.RequiredError('organization','Required parameter requestParameters.organization was null or undefined when calling apiV1OrganizationsOrganizationProjectsProjectClustersClusterPut.');
        }

        if (requestParameters.project === null || requestParameters.project === undefined) {
            throw new runtime.RequiredError('project','Required parameter requestParameters.project was null or undefined when calling apiV1OrganizationsOrganizationProjectsProjectClustersClusterPut.');
        }

        if (requestParameters.cluster === null || requestParameters.cluster === undefined) {
            throw new runtime.RequiredError('cluster','Required parameter requestParameters.cluster was null or undefined when calling apiV1OrganizationsOrganizationProjectsProjectClustersClusterPut.');
        }

        if (requestParameters.kubernetesClusterSpec === null || requestParameters.kubernetesClusterSpec === undefined) {
            throw new runtime.RequiredError('kubernetesClusterSpec','Required parameter requestParameters.kubernetesClusterSpec was null or undefined when calling apiV1OrganizationsOrganizationProjectsProjectClustersClusterPut.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("oauth2Authentication", []);
        }

        const response = await this.request({
            path: `/api/v1/organizations/{organization}/projects/{project}/clusters/{cluster}`.replace(`{${"organization"}}`, encodeURIComponent(String(requestParameters.organization))).replace(`{${"project"}}`, encodeURIComponent(String(requestParameters.project))).replace(`{${"cluster"}}`, encodeURIComponent(String(requestParameters.cluster))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: KubernetesClusterSpecToJSON(requestParameters.kubernetesClusterSpec),
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Update a cluster within the selected cluster manager.
     */
    async apiV1OrganizationsOrganizationProjectsProjectClustersClusterPut(requestParameters: ApiV1OrganizationsOrganizationProjectsProjectClustersClusterPutRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.apiV1OrganizationsOrganizationProjectsProjectClustersClusterPutRaw(requestParameters, initOverrides);
    }

    /**
     * Creates a new cluster within the selected cluster manager.
     */
    async apiV1OrganizationsOrganizationProjectsProjectClustersPostRaw(requestParameters: ApiV1OrganizationsOrganizationProjectsProjectClustersPostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.organization === null || requestParameters.organization === undefined) {
            throw new runtime.RequiredError('organization','Required parameter requestParameters.organization was null or undefined when calling apiV1OrganizationsOrganizationProjectsProjectClustersPost.');
        }

        if (requestParameters.project === null || requestParameters.project === undefined) {
            throw new runtime.RequiredError('project','Required parameter requestParameters.project was null or undefined when calling apiV1OrganizationsOrganizationProjectsProjectClustersPost.');
        }

        if (requestParameters.kubernetesClusterSpec === null || requestParameters.kubernetesClusterSpec === undefined) {
            throw new runtime.RequiredError('kubernetesClusterSpec','Required parameter requestParameters.kubernetesClusterSpec was null or undefined when calling apiV1OrganizationsOrganizationProjectsProjectClustersPost.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("oauth2Authentication", []);
        }

        const response = await this.request({
            path: `/api/v1/organizations/{organization}/projects/{project}/clusters`.replace(`{${"organization"}}`, encodeURIComponent(String(requestParameters.organization))).replace(`{${"project"}}`, encodeURIComponent(String(requestParameters.project))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: KubernetesClusterSpecToJSON(requestParameters.kubernetesClusterSpec),
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Creates a new cluster within the selected cluster manager.
     */
    async apiV1OrganizationsOrganizationProjectsProjectClustersPost(requestParameters: ApiV1OrganizationsOrganizationProjectsProjectClustersPostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.apiV1OrganizationsOrganizationProjectsProjectClustersPostRaw(requestParameters, initOverrides);
    }

    /**
     * List all regions.
     */
    async apiV1RegionsGetRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Regions>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("oauth2Authentication", []);
        }

        const response = await this.request({
            path: `/api/v1/regions`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => RegionsFromJSON(jsonValue));
    }

    /**
     * List all regions.
     */
    async apiV1RegionsGet(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Regions> {
        const response = await this.apiV1RegionsGetRaw(initOverrides);
        return await response.value();
    }

    /**
     * Lists all compute flavors that the authenticated user has access to
     */
    async apiV1RegionsRegionNameFlavorsGetRaw(requestParameters: ApiV1RegionsRegionNameFlavorsGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Flavors>> {
        if (requestParameters.regionName === null || requestParameters.regionName === undefined) {
            throw new runtime.RequiredError('regionName','Required parameter requestParameters.regionName was null or undefined when calling apiV1RegionsRegionNameFlavorsGet.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("oauth2Authentication", []);
        }

        const response = await this.request({
            path: `/api/v1/regions/{regionName}/flavors`.replace(`{${"regionName"}}`, encodeURIComponent(String(requestParameters.regionName))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => FlavorsFromJSON(jsonValue));
    }

    /**
     * Lists all compute flavors that the authenticated user has access to
     */
    async apiV1RegionsRegionNameFlavorsGet(requestParameters: ApiV1RegionsRegionNameFlavorsGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Flavors> {
        const response = await this.apiV1RegionsRegionNameFlavorsGetRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Lists all compute images that the authenticated user has access to.
     */
    async apiV1RegionsRegionNameImagesGetRaw(requestParameters: ApiV1RegionsRegionNameImagesGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Images>> {
        if (requestParameters.regionName === null || requestParameters.regionName === undefined) {
            throw new runtime.RequiredError('regionName','Required parameter requestParameters.regionName was null or undefined when calling apiV1RegionsRegionNameImagesGet.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("oauth2Authentication", []);
        }

        const response = await this.request({
            path: `/api/v1/regions/{regionName}/images`.replace(`{${"regionName"}}`, encodeURIComponent(String(requestParameters.regionName))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ImagesFromJSON(jsonValue));
    }

    /**
     * Lists all compute images that the authenticated user has access to.
     */
    async apiV1RegionsRegionNameImagesGet(requestParameters: ApiV1RegionsRegionNameImagesGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Images> {
        const response = await this.apiV1RegionsRegionNameImagesGetRaw(requestParameters, initOverrides);
        return await response.value();
    }

}
